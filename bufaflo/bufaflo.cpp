// bufaflo.cpp : Defines the entry point for the application.
//

#include <google/protobuf/compiler/code_generator.h>
#include <google/protobuf/compiler/plugin.h>
#include <google/protobuf/compiler/code_generator.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/io/printer.h>

using namespace google::protobuf;
using namespace std;

class Bufaflo : public compiler::CodeGenerator {
public:
	bool Generate(const FileDescriptor* file,
		const string& parameter,
		compiler::GeneratorContext* context,
		string* error) const
	{
		map<string, string> vars;
		map<string, const MethodDescriptor*> service_methods;

		// Set defaults
		for (int i = 0; i < file->service_count(); i++) {
			string service_name = file->service(i)->full_name();
			vars[service_name + "_impl_header"] = file->service(i)->name() + "_impl.h";
			vars[service_name + "_impl_classname"] = file->service(i)->name() + "Impl";
		}

		// Parse parameters
		vector<pair<string, string>> params;
		compiler::ParseGeneratorParameter(parameter, &params);

		// Handle parameters
		for (const auto param : params) {
			vars[param.first] = param.second;
		}

		string base_filename(file->name().substr(0, file->name().size() - 6));
		vars["base_filename"] = base_filename;
		vars["message_header_ext"] = ".pb.h";

		io::Printer printer(context->Open(base_filename + ".bufaflo.pb.cc"), '$');

		printer.Print(vars, "// Generated by Bufaflo plugin.\n");
		printer.Print(vars, "// If you make any local change, they will be lost.\n");
		printer.Print(vars, "\n");

		// Includes
		printer.Print(vars, "#include \"$base_filename$$message_header_ext$\"\n");
		printer.Print(vars, "#include \"$base_filename$.grpc$message_header_ext$\"\n");
		for (int i = 0; i < file->service_count(); i++) {
			string impl_include = "#include \"$" + file->service(i)->full_name() + "_impl_header$\" // Replace with Impl header\n";
			printer.Print(vars, impl_include.c_str());
		}
		printer.Print(vars, "#include <iostream>\n");
		printer.Print(vars, "#include <fstream>\n");
		printer.Print(vars, "#include <grpcpp/server_context.h>\n");
		printer.Print(vars, "\n");

		// extern
		printer.Print(vars, "extern \"C\" __declspec(dllexport) int main(int argc, const char* argv[]);\n");
		printer.Print(vars, "\n");

		// namespace
		printer.Print(vars, "using namespace std;\n");
		printer.Print(vars, "\n");

		// main method
		printer.Print(vars, "int main(int argc, const char* argv[]) {\n");
		printer.Indent();
		printer.Print(vars, "GOOGLE_PROTOBUF_VERIFY_VERSION;\n");

		// arg check and usage
		printer.Print(vars, "if (argc < 3) {\n");
		printer.Indent();
		printer.Print(vars, "printf(\"Usage: %s <Service Method> <protobuf file>\\n\", argv[0]);\n");
		printer.Print(vars, "printf(\"Service Method Options:\\n\");\n");
		for (int i = 0; i < file->service_count(); i++) {
			vars["service"] = file->service(i)->name();
			for (int j = 0; j < file->service(i)->method_count(); j++) {
				vars["method"] = file->service(i)->method(j)->name();
				printer.Print(vars, "printf(\"\\t$service$.$method$\\n\");\n");
				service_methods[vars["service"] + "." + vars["method"]] = file->service(i)->method(j);
			}
		}
		printer.Print(vars, "return 0;\n");
		printer.Outdent();
		printer.Print(vars, "}\n");
		printer.Print(vars, "\n");

		// open file containing protobuf message
		printer.Print(vars, "ifstream inFile;\n");
		printer.Print(vars, "inFile.open(argv[2], ios::binary | ios::in);\n");
		

		// declare and instantiate variables
		printer.Print(vars, "grpc::ServerContext context;\n");

		// For each service
		printer.Print(vars, "string service_method(argv[1]);\n");
		for (const auto service_method : service_methods) {
			vars["service_method"] = service_method.first;
			printer.Print(vars, "if (service_method == \"$service_method$\") {\n");
			printer.Indent();
			string instantiate_service("$" + service_method.second->service()->full_name() + "_impl_classname$ service; // Replace with Impl classname\n");
			printer.Print(vars, instantiate_service.c_str());

			// Instantiate variables for method parameters
			string input_type(service_method.second->input_type()->full_name());
			replaceAll(input_type, ".", "::");
			vars["input_type"] = input_type;
			string output_type(service_method.second->output_type()->full_name());
			replaceAll(output_type, ".", "::");
			vars["output_type"] = output_type;
			printer.Print(vars, "$input_type$ input;\n");
			printer.Print(vars, "$output_type$ output;\n");

			// Parse inFile
			printer.Print(vars, "input.ParseFromIstream(&inFile);\n");

			// Call service method
			vars["method"] = service_method.second->name();
			printer.Print(vars, "service.$method$(&context, &input, &output);\n");

			printer.Outdent();
			printer.Print(vars, "}\n");
		}
		printer.Print(vars, "\n");

		// Close file containing protobuf message
		printer.Print(vars, "inFile.close();\n");

		printer.Print(vars, "return 0;\n");
		printer.Outdent();
		printer.Print(vars, "}\n");

		return true;
	}

  private:
	int replaceAll(string& data, const string& search, const string& replace) const {
		size_t pos;
		unsigned int count = 0;
		while ((pos = data.find(search)) != string::npos) {
			data.replace(pos, search.size(), replace);
			count++;
		}
		return count;
	}
};

int main(int argc, char** argv)
{
	Bufaflo generator;
	return PluginMain(argc, argv, &generator);
}
